package ogpu.core

import chisel3._
import chisel3.util._
import org.chipsalliance.cde.config.Parameters
import ogpu.config._
import freechips.rocketchip.rocket._
import freechips.rocketchip.util._
import freechips.rocketchip.rocket.ALU._

// add join inst based on jal, use wxd to distinguish
/* Automatically generated by parse_opcodes */
object GPUInstructions {
  def JOIN = BitPat("b?????????????????000?????1101011")

}

import GPUInstructions._
class GPUDecode(
  implicit val p: Parameters)
    extends DecodeConstants {
  val aluFn = ALU
  val table: Array[(BitPat, List[BitPat])] = Array(
    // format: off
    JOIN -> List(
      Y,N,N,N,Y,N,N,N,N,N,N,A2_SIZE,A1_PC,IMM_UJ,DW_XPR,aluFn.FN_ADD,N,M_X,N,N,N,N,N,N,N,CSR.N,N,N,N,N))
    // format: on
}

// reuse rocketchip decode
class IDecodeUnit(
  implicit p: Parameters)
    extends Module() {
  val io = IO(new Bundle {
    val inst = Flipped(DecoupledIO(new InstData()))
    val decode = DecoupledIO(new DecodeData())
    val wcontrol = DecoupledIO(new WarpControlData())
  })

  val aluFn = ALU
  val decode_table = {
    Seq(new GPUDecode()) ++:
      Seq(new IDecode()) ++:
      Seq(new I64Decode())
  }.flatMap(_.table)
  val id_ctrl = Wire(new IntCtrlSigs()).decode(io.inst.bits.data, decode_table)
  val exec_ctrl = RegInit(0.U.asTypeOf(new IntCtrlSigs()))
  val ctrl_valid = RegInit(0.B)
  val decode_valid = RegInit(0.B)
  val inst_reg = RegInit(0.U.asTypeOf(io.inst.bits))
  when(io.inst.fire) {
    exec_ctrl := id_ctrl
    ctrl_valid := 1.B
    decode_valid := 1.B
    inst_reg := io.inst.bits
  }.otherwise {
    ctrl_valid := 0.B
  }

  when(io.decode.fire & !io.inst.fire) {
    decode_valid := 0.B
  }
  io.inst.ready := !io.decode.valid || io.decode.fire
  io.decode.valid := decode_valid
  io.wcontrol.valid := ctrl_valid

  val ctrl = exec_ctrl
  val is_alu = ctrl.wxd && !(ctrl.mem || ctrl.fp || ctrl.mul || ctrl.div || ctrl.csr =/= CSR.N)
  val is_lsu = ctrl.mem
  val is_csr = ctrl.csr =/= CSR.N

  // branch inst break warp schedule
  val is_jal = ctrl.wxd && ctrl.jal
  val is_jalr = ctrl.jalr
  val is_join = !ctrl.wxd && ctrl.jal
  val is_branch = ctrl.branch
  val is_end = inst_reg.data === 0x10500073.U
  val imm = ImmGen(ctrl.sel_imm, inst_reg.data)

  // output
  io.decode.bits.wid := inst_reg.wid
  io.decode.bits.mask := inst_reg.mask
  io.decode.bits.pc := inst_reg.pc
  io.decode.bits.ex_type.lsu := is_lsu
  io.decode.bits.ex_type.alu := is_alu

  io.decode.bits.func := ctrl.alu_fn
  io.decode.bits.mem_cmd := ctrl.mem_cmd(0)
  io.decode.bits.wb := ctrl.wxd
  io.decode.bits.sel_alu2 := ctrl.sel_alu2.asUInt
  io.decode.bits.sel_alu1 := ctrl.sel_alu1.asUInt
  io.decode.bits.imm := imm.asUInt
  io.decode.bits.branch.jal := is_jal
  io.decode.bits.branch.jalr := is_jalr
  io.decode.bits.branch.branch := is_branch
  io.decode.bits.rd := inst_reg.data(11, 7)
  io.decode.bits.rs1 := inst_reg.data(19, 15)
  io.decode.bits.rs2 := inst_reg.data(24, 20)

  io.wcontrol.bits.wid := inst_reg.wid
  io.wcontrol.bits.join := is_join
  io.wcontrol.bits.active := !(is_branch || is_jal || is_jalr || is_end)
  // wfi inst as end inst
  io.wcontrol.bits.end := is_end
}
